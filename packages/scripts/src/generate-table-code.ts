#!/usr/bin/env node
/**
 * Table Code Generator
 *
 * Scaffolds worker, permissions, event helpers, and tests for new database tables.
 *
 * Usage:
 *   pnpm codegen:table <tableName>
 *   pnpm codegen:table projects --dry-run
 */

import * as fs from "fs/promises";
import * as path from "path";
import {
  intro,
  outro,
  text,
  confirm,
  select,
  spinner,
  note,
} from "@clack/prompts";
import pc from "picocolors";

interface TableConfig {
  tableName: string;
  hasWorkspace: boolean;
  hasUserId: boolean;
  generateTests: boolean;
}

interface GeneratedFiles {
  worker: string;
  permissions: string;
  helpers: string;
  tests?: string;
}

const BACKEND_ROOT = path.resolve(process.cwd(), "../..");

async function main() {
  const args = process.argv.slice(2);
  const tableName = args[0];
  const isDryRun = args.includes("--dry-run");

  intro(pc.bgCyan(pc.black(" Table Code Generator ")));

  // Validate table name
  if (!tableName) {
    note("Usage: pnpm codegen:table <tableName>", "Error");
    process.exit(1);
  }

  console.log(pc.dim(`Generating code for table: ${pc.cyan(tableName)}\n`));

  // Interactive prompts
  const hasWorkspace = await confirm({
    message: "Does this table belong to a workspace?",
    initialValue: false,
  });

  const hasUserId = await confirm({
    message: "Does this table have a userId field (owner)?",
    initialValue: true,
  });

  const generateTests = await confirm({
    message: "Generate test files?",
    initialValue: true,
  });

  if (
    hasWorkspace === false ||
    hasUserId === false ||
    generateTests === false
  ) {
    outro(pc.red("Cancelled"));
    process.exit(0);
  }

  const config: TableConfig = {
    tableName,
    hasWorkspace: Boolean(hasWorkspace),
    hasUserId: Boolean(hasUserId),
    generateTests: Boolean(generateTests),
  };

  // Generate code
  const s = spinner();
  s.start("Generating files...");

  try {
    const files = await generateAllFiles(config);

    if (isDryRun) {
      s.stop(pc.yellow("Dry run - files not written"));
      console.log("\n" + pc.bold("Generated files preview:\n"));
      Object.entries(files).forEach(([name, content]) => {
        console.log(pc.cyan(`${name}:`));
        console.log(pc.dim(content.substring(0, 200) + "...\n"));
      });
    } else {
      await writeFiles(config, files);
      s.stop(pc.green("Files generated successfully"));

      note(
        `${pc.green("âœ“")} Worker: packages/jobs/src/functions/${tableName}.ts\n` +
          `${pc.green("âœ“")} Tests: packages/jobs/src/functions/${tableName}.test.ts\n` +
          `${pc.green("âœ“")} Event Helpers: packages/events/src/helpers/${tableName}.ts\n` +
          `${pc.yellow("âš ")} Updated: permission-validator.ts (review changes)\n` +
          `${pc.yellow("âš ")} Updated: index.ts (review changes)`,
        "Generated Files",
      );

      note(
        `1. Review generated files\n` +
          `2. Customize TODO sections as needed\n` +
          `3. Run: ${pc.cyan(`pnpm --filter @synap/jobs test ${tableName}`)}\n` +
          `4. Commit changes`,
        "Next Steps",
      );
    }

    outro(pc.green("Done! ðŸŽ‰"));
  } catch (error) {
    s.stop(pc.red("Generation failed"));
    console.error(error);
    process.exit(1);
  }
}

async function generateAllFiles(config: TableConfig): Promise<GeneratedFiles> {
  const { tableName, hasWorkspace, hasUserId, generateTests } = config;

  return {
    worker: generateWorker(config),
    permissions: generatePermissionSnippet(config),
    helpers: generateEventHelpers(config),
    ...(generateTests && { tests: generateTests_file(config) }),
  };
}

function generateWorker(config: TableConfig): string {
  const { tableName, hasWorkspace } = config;
  const TableName = capitalize(tableName);
  const roomId = hasWorkspace ? `workspaceId: data.workspaceId` : `userId`;

  return `/**
 * ${TableName} Worker
 * 
 * Auto-generated by codegen:table
 * Customize TODO sections as needed
 */

import { inngest } from '../client.js';
import { db } from '@synap/database';
import { ${tableName} } from '@synap/database/schema';
import { eq } from 'drizzle-orm';
import { publishEvent } from '@synap/events';
import { createLogger } from '@synap-core/core';

const logger = createLogger({ module: '${tableName}-worker' });
const REALTIME_URL = process.env.REALTIME_URL || 'http://localhost:3001';

export const ${tableName}Worker = inngest.createFunction(
  { id: '${tableName}-worker' },
  [
    { event: '${tableName}.create.approved' },
    { event: '${tableName}.update.approved' },
    { event: '${tableName}.delete.approved' },
  ],
  async ({ event, step }) => {
    const action = event.name.split('.')[1] as 'create' | 'update' | 'delete';
    const userId = event.user.id;
    const data = event.data;

    if (action === 'create') {
      // STEP 1: Create in database
      await step.run('create-${tableName}', async () => {
        // TODO: Customize field mapping
        await db.insert(${tableName}).values({
          id: data.${tableName}Id,
          userId,
          ${hasWorkspace ? "workspaceId: data.workspaceId," : ""}
          // TODO: Add other fields from data
        });
        
        logger.info({ ${tableName}Id: data.${tableName}Id }, 'Created ${tableName}');
      });

      // STEP 2: Emit validated event
      await step.run('emit-validated', async () => {
        await publishEvent({
          type: '${tableName}.create.validated',
          data: { ${tableName}Id: data.${tableName}Id },
          userId
        });
      });

      // STEP 3: Real-time update
      await step.run('emit-socketio', async () => {
        try {
          await fetch(\`\${REALTIME_URL}/bridge/emit\`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              event: '${tableName}:created',
              ${roomId},
              data: { ${tableName}Id: data.${tableName}Id }
            })
          });
        } catch (error) {
          logger.warn({ err: error }, 'Failed to emit Socket.IO event');
        }
      });
    }

    if (action === 'update') {
      // STEP 1: Update in database
      await step.run('update-${tableName}', async () => {
        // TODO: Implement update logic
        await db.update(${tableName})
          .set({
            // TODO: Map update fields
            updatedAt: new Date()
          })
          .where(eq(${tableName}.id, data.${tableName}Id));
        
        logger.info({ ${tableName}Id: data.${tableName}Id }, 'Updated ${tableName}');
      });

      // STEP 2: Emit validated
      await step.run('emit-validated', async () => {
        await publishEvent({
          type: '${tableName}.update.validated',
          data: { ${tableName}Id: data.${tableName}Id },
          userId
        });
      });

      // STEP 3: Real-time update
      await step.run('emit-socketio', async () => {
        try {
          await fetch(\`\${REALTIME_URL}/bridge/emit\`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              event: '${tableName}:updated',
              ${roomId},
              data: { ${tableName}Id: data.${tableName}Id }
            })
          });
        } catch (error) {
          logger.warn({ err: error }, 'Failed to emit Socket.IO event');
        }
      });
    }

    if (action === 'delete') {
      // STEP 1: Soft delete
      await step.run('delete-${tableName}', async () => {
        // TODO: Implement soft delete
        await db.update(${tableName})
          .set({ deletedAt: new Date() })
          .where(eq(${tableName}.id, data.${tableName}Id));
        
        logger.info({ ${tableName}Id: data.${tableName}Id }, 'Deleted ${tableName}');
      });

      // STEP 2: Emit validated
      await step.run('emit-validated', async () => {
        await publishEvent({
          type: '${tableName}.delete.validated',
          data: { ${tableName}Id: data.${tableName}Id },
          userId
        });
      });

      // STEP 3: Real-time update
      await step.run('emit-socketio', async () => {
        try {
          await fetch(\`\${REALTIME_URL}/bridge/emit\`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              event: '${tableName}:deleted',
              ${roomId},
              data: { ${tableName}Id: data.${tableName}Id }
            })
          });
        } catch (error) {
          logger.warn({ err: error }, 'Failed to emit Socket.IO event');
        }
      });
    }
  }
);
`;
}

function generatePermissionSnippet(config: TableConfig): string {
  const { tableName, hasWorkspace } = config;

  return `
    // ========================================
    // ${capitalize(tableName)} Permissions
    // Auto-generated - customize as needed
    // ========================================
    if (table === '${tableName}') {
      if (action === 'create') {
        ${
          hasWorkspace
            ? `
        // Check workspace membership
        const isMember = await db.select()
          .from(workspaceMembers)
          .where(and(
            eq(workspaceMembers.workspaceId, metadata.workspaceId),
            eq(workspaceMembers.userId, userId)
          ))
          .limit(1);
        
        if (isMember.length > 0) {
          await publishApproved();
          return { approved: true, reason: 'Workspace member' };
        }
        return { approved: false, reason: 'Not a workspace member' };
        `
            : `
        // Auto-approve owner creating their own resource
        await publishApproved();
        return { approved: true, reason: 'Owner can create' };
        `
        }
      }
      
      if (action === 'update' || action === 'delete') {
        // Check ownership
        const resource = await db.select()
          .from(${tableName})
          .where(eq(${tableName}.id, resourceId))
          .limit(1);
        
        const isOwner = resource[0]?.userId === userId;
        
        if (isOwner) {
          await publishApproved();
          return { approved: true, reason: 'Owner' };
        }
        
        ${
          hasWorkspace
            ? `
        // TODO: Add workspace admin/editor check if needed
        `
            : ""
        }
        
        return { approved: false, reason: 'Not authorized' };
      }
    }
`;
}

function generateEventHelpers(config: TableConfig): string {
  const { tableName } = config;
  const TableName = capitalize(tableName);

  return `/**
 * ${TableName} Event Helpers
 * 
 * Auto-generated by codegen:table
 */

import { publishEvent } from '../publisher.js';

export const ${TableName}Events = {
  createRequested: async (userId: string, data: any) => {
    return publishEvent({
      type: '${tableName}.create.requested',
      data,
      userId
    });
  },

  updateRequested: async (userId: string, ${tableName}Id: string, updates: any) => {
    return publishEvent({
      type: '${tableName}.update.requested',
      data: { ${tableName}Id, ...updates },
      userId
    });
  },

  deleteRequested: async (userId: string, ${tableName}Id: string) => {
    return publishEvent({
      type: '${tableName}.delete.requested',
      data: { ${tableName}Id },
      userId
    });
  },
};
`;
}

function generateTests_file(config: TableConfig): string {
  const { tableName, hasWorkspace } = config;
  const TableName = capitalize(tableName);

  return `/**
 * ${TableName} Worker Tests
 * 
 * Auto-generated by codegen:table
 */

import { describe, it, expect, beforeAll, afterAll, vi } from 'vitest';
import { ${tableName}Worker } from './${tableName}.js';
import { db, sql } from '@synap/database';
import { ${tableName} } from '@synap/database/schema';
import { publishEvent } from '@synap/events';
import crypto from 'crypto';

// Mock publishEvent
vi.mock('@synap/events', () => ({
  publishEvent: vi.fn()
}));

// Mock fetch for Socket.IO bridge
global.fetch = vi.fn(() =>
  Promise.resolve({
    ok: true,
    json: async () => ({ success: true })
  } as Response)
);

function generateTestUserId() {
  return \`test-\${crypto.randomUUID().slice(0, 8)}\`;
}

describe('${TableName} Worker', () => {
  beforeAll(async () => {
    await sql\`DELETE FROM \${${tableName}} WHERE user_id LIKE 'test-%'\`;
  });

  afterAll(async () => {
    await sql\`DELETE FROM \${${tableName}} WHERE user_id LIKE 'test-%'\`;
    await sql.end();
  });

  it('should create ${tableName} on approved event', async () => {
    const userId = generateTestUserId();
    const ${tableName}Id = crypto.randomUUID();

    const mockEvent = {
      event: {
        name: '${tableName}.create.approved',
        data: {
          ${tableName}Id,
          ${hasWorkspace ? "workspaceId: crypto.randomUUID()," : ""}
          // TODO: Add required fields
        },
        user: { id: userId }
      },
      step: {
        run: vi.fn((name, fn) => fn())
      }
    };

    await ${tableName}Worker.handler(mockEvent as any);

    // Verify DB operation
    const [created] = await sql\`
      SELECT * FROM \${${tableName}} WHERE id = \${${tableName}Id}
    \`;

    expect(created).toBeDefined();
    expect(created.user_id).toBe(userId);

    // Verify validated event
    expect(publishEvent).toHaveBeenCalledWith({
      type: '${tableName}.create.validated',
      data: { ${tableName}Id },
      userId
    });

    // Verify Socket.IO emission
    expect(fetch).toHaveBeenCalledWith(
      expect.stringContaining('/bridge/emit'),
      expect.objectContaining({
        method: 'POST'
      })
    );
  });

  it('should update ${tableName} on approved event', async () => {
    // TODO: Implement update test
  });

  it('should delete ${tableName} on approved event', async () => {
    // TODO: Implement delete test
  });
});
`;
}

async function writeFiles(config: TableConfig, files: GeneratedFiles) {
  const { tableName } = config;

  // Write worker
  const workerPath = path.join(
    BACKEND_ROOT,
    "packages/jobs/src/functions",
    `${tableName}.ts`,
  );
  await fs.writeFile(workerPath, files.worker, "utf-8");

  // Write tests
  if (files.tests) {
    const testsPath = path.join(
      BACKEND_ROOT,
      "packages/jobs/src/functions",
      `${tableName}.test.ts`,
    );
    await fs.writeFile(testsPath, files.tests, "utf-8");
  }

  // Write event helpers
  const helpersPath = path.join(
    BACKEND_ROOT,
    "packages/events/src/helpers",
    `${tableName}.ts`,
  );
  await fs.writeFile(helpersPath, files.helpers, "utf-8");

  // Update permission-validator.ts (append)
  const permValidatorPath = path.join(
    BACKEND_ROOT,
    "packages/jobs/src/functions/permission-validator.ts",
  );
  const permContent = await fs.readFile(permValidatorPath, "utf-8");

  // Find the last closing brace of the main switch/if statement and insert before it
  const insertMarker = "  // END OF AUTO-GENERATED PERMISSIONS";
  const updatedPerm = permContent.replace(
    insertMarker,
    files.permissions + "\n    " + insertMarker,
  );
  await fs.writeFile(permValidatorPath, updatedPerm, "utf-8");

  // Update index.ts (add worker to exports and functions array)
  const indexPath = path.join(BACKEND_ROOT, "packages/jobs/src/index.ts");
  const indexContent = await fs.readFile(indexPath, "utf-8");

  // Add import
  const importLine = `import { ${tableName}Worker } from './functions/${tableName}.js';\n`;
  const updatedIndex = indexContent.replace(
    "import { permissionValidator }",
    importLine + "import { permissionValidator }",
  );

  // Add to functions array
  const functionLine = `  ${tableName}Worker,\n`;
  const finalIndex = updatedIndex.replace(
    "  permissionValidator, // Phase 2",
    `  permissionValidator, // Phase 2\n${functionLine}`,
  );

  await fs.writeFile(indexPath, finalIndex, "utf-8");
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

main().catch(console.error);
