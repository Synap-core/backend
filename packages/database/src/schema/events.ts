/**
 * Events Schema - The Immutable Source of Truth
 *
 * This table stores every event that happens in the system.
 * Events are NEVER updated or deleted, only appended.
 *
 * Event Sourcing: Each event references a subject (the thing it's about)
 * via subjectId and subjectType. We can rebuild any subject's state by
 * replaying its events in order.
 *
 * PostgreSQL-only schema with Row-Level Security (RLS) for multi-user support.
 */

import {
  pgTable,
  uuid,
  timestamp,
  jsonb,
  text,
  index,
} from "drizzle-orm/pg-core";

export const events = pgTable(
  "events",
  {
    // Primary key (UUID auto-generated by PostgreSQL)
    id: uuid("id").defaultRandom().primaryKey(),

    // When did this event occur? (for ordering and replay)
    timestamp: timestamp("timestamp", { mode: "date", withTimezone: true })
      .defaultNow()
      .notNull(),

    // What type of event is this?
    type: text("type").notNull(),

    // ✨ EVENT SOURCING: What is this event about?
    // subjectId: The ID of the thing this event affects (inbox item, entity, document, etc.)
    // subjectType: The type of subject (inbox_item, entity, note, task, document, etc.)
    subjectId: text("subject_id").notNull(),
    subjectType: text("subject_type").notNull(),

    // Event data payload - WHAT happened (JSONB for efficient queries)
    data: jsonb("data").notNull(),

    // Event metadata - HOW/WHY it happened (AI enrichment, import context, sync info, etc.)
    // This is the extensibility point - any intelligence or integration can add context here
    metadata: jsonb("metadata"),

    // Where did this event come from?
    source: text("source").default("api"),

    // For tracing related events
    correlationId: uuid("correlation_id"),

    // Which user does this event belong to?
    userId: text("user_id").notNull(),
  },
  (table) => ({
    // ✨ INDEX: For event sourcing queries - "get all events for this subject"
    subjectIdx: index("idx_events_subject").on(
      table.subjectType,
      table.subjectId,
      table.timestamp,
    ),

    // INDEX: For querying by user and event type
    userTypeIdx: index("idx_events_user_type").on(table.userId, table.type),

    // INDEX: For time-based queries
    timestampIdx: index("idx_events_timestamp").on(table.timestamp),
  }),
);

export type Event = typeof events.$inferSelect;
export type NewEvent = typeof events.$inferInsert;

import { createInsertSchema, createSelectSchema } from "drizzle-zod";

/**
 * @internal For monorepo usage - enables schema composition in API layer
 */
export const insertEventSchema = createInsertSchema(events);
/**
 * @internal For monorepo usage - enables schema composition in API layer
 */
export const selectEventSchema = createSelectSchema(events);
