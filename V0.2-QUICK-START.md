# ğŸš€ V0.2 Quick Start Guide - Multi-User SaaS

**Status**: Ready to Test  
**Branch**: `main`  
**Mode**: Multi-User PostgreSQL + Better Auth

---

## ğŸ“‹ Prerequisites

### 1. Neon PostgreSQL Database

1. **Create Account**: https://neon.tech
2. **Create Project**: "synap-backend-production"
3. **Copy Connection String**:
   ```
   postgresql://user:password@ep-xxx.neon.tech/synap?sslmode=require
   ```

### 2. Environment Variables

Create `.env.production`:

```bash
# Database
DB_DIALECT=postgres
DATABASE_URL=postgresql://user:password@ep-xxx.neon.tech/synap?sslmode=require

# Better Auth
BETTER_AUTH_SECRET=your-secret-here  # Generate: openssl rand -base64 32
BETTER_AUTH_URL=http://localhost:3000

# OAuth Providers (optional for testing)
GOOGLE_CLIENT_ID=your-google-client-id
GOOGLE_CLIENT_SECRET=your-google-client-secret
GITHUB_CLIENT_ID=your-github-client-id
GITHUB_CLIENT_SECRET=your-github-client-secret

# AI
ANTHROPIC_API_KEY=sk-ant-your-api-key-here
OPENAI_API_KEY=sk-proj-your-key-here  # For embeddings

# Inngest
INNGEST_EVENT_KEY=your-inngest-key
INNGEST_SIGNING_KEY=your-inngest-signing-key

# Server
PORT=3000
NODE_ENV=production
```

---

## ğŸ”§ Installation

### 1. Install Dependencies

```bash
cd /Users/antoine/Documents/Code/synap-backend
pnpm install
```

### 2. Initialize Database

```bash
# Load environment
export $(cat .env.production | xargs)

# Run initialization script
./scripts/init-postgres.sh
```

This script will:
- âœ… Enable pgvector extension
- âœ… Create all tables (events, entities, content_blocks, relations, etc.)
- âœ… Enable Row-Level Security (RLS)
- âœ… Create performance indexes
- âœ… Verify setup

**Expected Output**:
```
ğŸš€ Initializing Synap PostgreSQL Database...
âœ… DATABASE_URL is set

ğŸ“¦ Step 1/4: Enabling pgvector extension...
âœ… pgvector enabled

ğŸ“Š Step 2/4: Pushing Drizzle schemas...
âœ… Schemas pushed

ğŸ”’ Step 3/4: Enabling Row-Level Security...
âœ… RLS enabled

âœ… Step 4/4: Verifying setup...
   Tables created: 7
   Tables with RLS: 7
   pgvector: âœ… Enabled

ğŸ‰ Database initialization complete!
```

---

## ğŸ§ª Run Tests

### Multi-User Isolation Tests

```bash
export $(cat .env.production | xargs)
pnpm --filter @synap/core test multi-user
```

**Expected Output**:
```
âœ… User A created note
âœ… User A can read their own data
âœ… User B CANNOT see User A data (RLS working!)
âœ… User B created their own note
âœ… Search results are isolated between users
âœ… Cross-user updates blocked by RLS
âœ… Cross-user deletes blocked by RLS

Test Files  1 passed (1)
     Tests  7 passed (7)
```

---

## ğŸƒ Start Servers

### Terminal 1: API Server

```bash
export $(cat .env.production | xargs)
pnpm --filter api dev
```

**Expected Output**:
```
ğŸš€ Synap API starting on port 3000
âœ… Better Auth routes enabled at /api/auth/*
âœ… Server running at http://localhost:3000
ğŸ“¡ tRPC API: http://localhost:3000/api/trpc
ğŸ” Auth API: http://localhost:3000/api/auth
```

### Terminal 2: Inngest Jobs

```bash
export $(cat .env.production | xargs)
pnpm --filter jobs dev
```

---

## ğŸ” Setup OAuth (Optional)

### Google OAuth

1. Go to https://console.cloud.google.com
2. Create project "Synap"
3. Enable Google+ API
4. Create OAuth 2.0 credentials:
   - **Authorized redirect URIs**: `http://localhost:3000/api/auth/callback/google`
5. Copy Client ID and Secret to `.env.production`

### GitHub OAuth

1. Go to https://github.com/settings/developers
2. New OAuth App:
   - **Application name**: Synap Backend
   - **Homepage URL**: `http://localhost:3000`
   - **Authorization callback URL**: `http://localhost:3000/api/auth/callback/github`
3. Copy Client ID and Secret to `.env.production`

---

## ğŸ“– API Endpoints

### Authentication (Better Auth)

```bash
# Sign up with email/password
POST /api/auth/sign-up
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "secure-password",
  "name": "John Doe"
}

# Sign in
POST /api/auth/sign-in
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "secure-password"
}

# OAuth sign in
GET /api/auth/google    # Redirects to Google
GET /api/auth/github    # Redirects to GitHub

# Get session
GET /api/auth/session
Cookie: better-auth.session=...

# Sign out
POST /api/auth/sign-out
Cookie: better-auth.session=...
```

### tRPC (Protected, requires session)

```bash
# Create note
POST /trpc/notes.create
Cookie: better-auth.session=...
Content-Type: application/json

{
  "content": "My first note",
  "autoEnrich": true,
  "useRAG": true
}

# Search notes
GET /trpc/notes.search?input={"query":"my note","useRAG":true}
Cookie: better-auth.session=...
```

---

## ğŸ§© Architecture Overview

### Authentication Flow

```
1. User signs up/in â†’ Better Auth creates session
2. Session stored in PostgreSQL (users, sessions tables)
3. Cookie sent to client: better-auth.session=...
4. Every request â†’ getSession() â†’ ctx.userId
5. Before DB query â†’ SET app.current_user_id = userId
6. RLS automatically filters all queries
```

### Multi-User Isolation

```sql
-- User A signs in
SET app.current_user_id = 'user-a-id';

-- User A creates note
INSERT INTO entities (title, user_id) VALUES ('Note A', 'user-a-id');

-- User B signs in
SET app.current_user_id = 'user-b-id';

-- User B searches (RLS filters automatically)
SELECT * FROM entities;
-- Returns ONLY entities where user_id = 'user-b-id'
-- User A's data is invisible!
```

### RLS Policies

Every table has a policy:

```sql
CREATE POLICY user_isolation_entities ON entities
  FOR ALL
  USING (user_id = current_setting('app.current_user_id'))
  WITH CHECK (user_id = current_setting('app.current_user_id'));
```

**Benefits**:
- âœ… Database-level security (impossible to bypass)
- âœ… No manual `WHERE user_id = ?` needed
- âœ… Works with raw SQL, ORMs, everything
- âœ… Performance optimized with indexes

---

## ğŸ› Troubleshooting

### Error: "pgvector extension not found"

**Solution**: Run migrations:
```bash
psql $DATABASE_URL < packages/database/migrations-pg/0001_enable_pgvector.sql
```

### Error: "Unauthorized"

**Cause**: No valid session

**Solution**:
1. Check cookie: `better-auth.session`
2. Sign in again
3. Verify `BETTER_AUTH_SECRET` is set

### Error: "Cannot read property 'userId' of undefined"

**Cause**: RLS context not set

**Solution**: Check `betterAuthMiddleware` in `packages/auth/src/better-auth.ts`:
```typescript
await db.execute(sql`SET LOCAL app.current_user_id = ${session.user.id}`);
```

### Tests fail with "RLS not enabled"

**Solution**: Run RLS migration:
```bash
psql $DATABASE_URL < packages/database/migrations-pg/0002_enable_rls.sql
```

---

## ğŸ“Š Verify RLS is Working

### Manual Test

```bash
# Connect to database
psql $DATABASE_URL

# Check RLS is enabled
SELECT schemaname, tablename, rowsecurity 
FROM pg_tables 
WHERE schemaname = 'public';

# Should show rowsecurity = true for all tables

# List policies
SELECT tablename, policyname 
FROM pg_policies 
WHERE schemaname = 'public';

# Should show policies like: user_isolation_events, user_isolation_entities, etc.

# Test isolation
SET app.current_user_id = 'test-user-1';
INSERT INTO entities (type, title, user_id) VALUES ('note', 'Test', 'test-user-1');

SET app.current_user_id = 'test-user-2';
SELECT * FROM entities;
-- Should return EMPTY (test-user-2 cannot see test-user-1's data)

SET app.current_user_id = 'test-user-1';
SELECT * FROM entities;
-- Should return 1 row (test-user-1 can see their own data)
```

---

## ğŸ¯ Next Steps

1. âœ… Database initialized
2. âœ… Tests passing
3. âœ… API server running
4. â³ **Setup OAuth** (optional for testing)
5. â³ **Test user flows**:
   - Sign up
   - Create note
   - Search notes
   - Verify isolation
6. â³ **Deploy to production**
7. â³ **Build frontend** (React/Next.js)

---

## ğŸ“š Documentation

- **Architecture**: `ARCHITECTURE.md`
- **Migration Guide**: `MIGRATION-V0.1-TO-V0.2.md`
- **Progress Report**: `V0.2-PROGRESS-REPORT.md`
- **Roadmap**: `ROADMAP.md`

---

**Questions?** Check the docs or create an issue on GitHub.

**Ready to build the future of personal knowledge management!** ğŸš€

